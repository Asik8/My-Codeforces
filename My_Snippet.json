{
  "Cpp Syntext": {
    "prefix": "cpp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define ll long long",
      "#define pb push_back",
      "#define py cout<<\"YES\\n\";",
      "#define pn cout<<\"NO\\n\";",
      "#define forni for (int i = 0; i < n; i++)",
      "#define fornj for (int j = 0; j < n; j++)",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ll t;",
      "    cin >> t;",
      "    while (t--) {",
      "        ll n;",
      "        cin >> n;",
      "        vector <ll> v(n);",
      "        for (auto& x:v) cin >>x;       ",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": ""
  },
  "Cpp-2":{
	  "prefix": "cpp-2",
	  "body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"#define pb push_back",
		"#define py cout<<\"YES\\n\";",
		"#define pn cout<<\"NO\\n\";",
		"#define forni for (int i = 0; i < n; i++)",
		"#define fornj for (int j = 0; j < n; j++)",
		"",
		"int main(){",
		"    ios::sync_with_stdio(false);",
		"    cin.tie(NULL);",
		"    ll n;",
		"    cin >> n;",
		"    vector <ll> v(n);",
		"    for (auto& x:v) cin >>x;       ",
		"    return 0;",
		"}"
	  ],
	  "description": ""
	},
	"Cpp-3":{
	  "prefix": "cpp-3",
	  "body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"#define ll long long",
		"#define pb push_back",
		"#define py cout<<\"YES\\n\";",
		"#define pn cout<<\"NO\\n\";",
		"#define forni for (int i = 0; i < n; i++)",
		"#define fornj for (int j = 0; j < n; j++)",
		"",
		"int main(){",
		"    ios::sync_with_stdio(false);",
		"    cin.tie(NULL);",

		"    return 0;",
		"}"
	  ],
	  "description": ""
	},
  
  "Singly Linked LIst": {
    "prefix": "node",
    "body": [
      "class Node {",
      "public:",
      "    ll data;",
      "    Node *next;",
      "",
      "    Node(ll data) {",
      "        this->data = data;",
      "        next = NULL;",
      "    }",
      "};"
    ],
    "description": ""
  },
  
  "Doubly Linked List": {
    "prefix": "dnode",
    "body": [
      "class Node {",
      "public:",
      "    int data;",
      "    Node *next;",
      "    Node *prev;",
      "",
      "    Node(int data) {",
      "        this->data = data;",
      "        next = NULL;",
      "        prev = NULL;",
      "    }",
      "};"
    ],
    "description": ""
  },
  
  "Binary Tree": {
    "prefix": "bnode",
    "body": [
      "class Node {",
      "public:",
      "    ll data;",
      "    Node *left;",
      "    Node *right;",
      "",
      "    Node(ll data) {",
      "        this->data = data;",
      "        this->left = NULL;",
      "        this->right = NULL;",
      "    }",
      "};"
    ],
    "description": ""
  },
  
  "Binary Tree Input": {
    "prefix": "btree",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define ll long long",
      "",
      "class Node {",
      "public:",
      "    ll data;",
      "    Node *left;",
      "    Node *right;",
      "",
      "    Node(ll data) {",
      "        this->data = data;",
      "        this->left = NULL;",
      "        this->right = NULL;",
      "    }",
      "};",
      "",
      "Node * Input_Tree() ",
      "{",
      "    int n;",
      "    cin>>n;",
      "    Node * root;",
      "    if(n != -1) root = new Node(n);",
      "    else root = NULL;",
      "    queue<Node*>q;",
      "    if(root) q.push(root);",
      "    while(!q.empty())",
      "    {",
      "        Node *f = q.front();",
      "        q.pop(); ",
      "        int l,r;",
      "        cin>>l>>r;",
      "        Node *newLeft = NULL;",
      "        Node *newRight = NULL;",
      "        if(l != -1) newLeft = new Node(l);",
      "        if(r != -1) newRight = new Node(r);",
      "        f->left = newLeft;",
      "        f->right = newRight;",
      "        if(f->left) q.push(newLeft);",
      "        if(f->right) q.push(newRight);",
      "    }",
      "    return root;",
      "}",
      "",
      "void Print_LevelOrder(Node *root) ",
      "{",
      "    if(!root) return;",
      "    queue<Node*>q;",
      "    q.push(root);",
      "    while(!q.empty())",
      "    {",
      "        Node* f = q.front();",
      "        q.pop();",
      "        cout<<f->data<<\" \";",
      "        if(f->left)q.push(f->left);",
      "        if(f->right)q.push(f->right);",
      "    }",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    Node *root = Input_Tree();",
      "    Print_LevelOrder(root);",
      "    return 0;",
      "}"
    ],
    "description": ""
  },
  "Find the Shortest Path Length": {
    "prefix": "bfs_length",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define ll long long",
      "#define pb push_back",
      "",
      "const int N = 1e5+5;",
      "vector<int> v[N];",
      "bool vis[N];",
      "vector<ll> path;",
      "ll level[N];",
      "ll parent[N];",
      "",
      "void bfs_Path_Length(ll s,ll d)",
      "{",
      "    if(s == d)",
      "    {",
      "        cout<<0<<endl;",
      "        return;",
      "    }",
      "    queue<ll>q;",
      "    q.push(s);",
      "    level[s] = 0;",
      "    vis[s] = true;",
      "    while(!q.empty())",
      "    {",
      "        ll n = q.front();",
      "        q.pop();",
      "        for(ll x:v[n])",
      "        {",
      "            if(!vis[x])",
      "            {",
      "                q.push(x);",
      "                level[x] = level[n]+1;",
      "                vis[x] = true;",
      "                parent[x] = n;",
      "            }",
      "        }",
      "    }",
      "    if(parent[d] == -1) ",
      "    {",
      "        cout<<-1<<endl;",
      "        return;",
      "    }",
      "    ll l = d;",
      "    while(1)",
      "    {",
      "        if(l == -1) break;",
      "        path.pb(l);",
      "        l = parent[l];",
      "    }",
      "    cout<<path.size()-1<<endl;",
      "    path.clear();",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ll n,e;",
      "    cin>>n>>e;",
      "    while(e--)",
      "    {",
      "        int a,b;",
      "        cin>>a>>b;",
      "        v[a].pb(b);",
      "        v[b].pb(a);",
      "    }",
      "    ll q;",
      "    cin>>q;",
      "    while(q--)",
      "    {",
      "        ll s,d;",
      "        cin>>s>>d;",
      "        memset(vis,false,sizeof(vis));",
      "        memset(parent,-1,sizeof(parent));",
      "        memset(level,-1,sizeof(level));",
      "        bfs_Path_Length(s,d);",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": ""
  },
  "BFS Shortest Path": {
    "prefix": "bfs_path",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define ll long long",
      "#define pb push_back",
      "",
      "const ll N = 1e5+10;",
      "vector<ll> ar[N];",
      "bool vis[N];",
      "ll level[N]; ",
      "ll parent[N];",
      "",
      "void bfs(ll src)",
      "{",
      "    queue<ll>q;",
      "    q.push(src);",
      "    vis[src] = true;",
      "    level[src] = 0;",
      "    while(!q.empty())",
      "    {",
      "        ll n = q.front();",
      "        q.pop();",
      "        for(ll x:ar[n])",
      "        {",
      "            if(!vis[x]) ",
      "            {",
      "                q.push(x);",
      "                vis[x] = true;",
      "                level[x] = level[n]+1;",
      "                parent[x] = n;",
      "            }",
      "        }",
      "    }",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ll n,e;",
      "    cin>>n>>e;",
      "    while(e--)",
      "    {",
      "        ll a,b;",
      "        cin>>a>>b;",
      "        ar[a].pb(b);",
      "        ar[b].pb(a);",
      "    }",
      "    ll src,des;",
      "    cin>>src>>des;",
      "    memset(vis,false,sizeof(vis));",
      "    memset(level,-1,sizeof(level));",
      "    memset(parent,-1,sizeof(parent));",
      "    bfs(src);",
      "    vector <ll> v;",
      "    ll x = des;",
      "    while(x!=-1)",
      "    {",
      "        if(x != -1) v.pb(x);",
      "        x = parent[x];",
      "    }",
      "    reverse(v.begin(),v.end());",
      "    for(ll l:v) cout<<l<<\" \";",
      "    return 0;",
      "}"
    ],
    "description": ""
  },
  "Graph Components using DFS": {
    "prefix": "dfs_components",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define ll long long",
      "#define pb push_back",
      "",
      "const ll N = 1e5+10;",
      "vector<ll> v[N];",
      "bool vis[N];",
      "",
      "void DFS(ll n)",
      "{",
      "    vis[n] = true;",
      "    for(ll x:v[n])",
      "    {",
      "        if(!vis[x])",
      "        {",
      "            DFS(x);",
      "        }",
      "    }",
      "}",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(NULL);",
      "    ll n,e;",
      "    cin>>n>>e;",
      "    while(e--)",
      "    {",
      "        ll a,b;",
      "        cin>>a>>b;",
      "        v[a].pb(b);",
      "        v[b].pb(a);",
      "    }",
      "    ll c=0;",
      "    for (int i=0;i<n;i++)",
      "    {",
      "        if(!vis[i])",
      "        {",
      "            c++;",
      "            DFS(i);",
      "        }",
      "    }   ",
      "    cout<<c<<endl;    ",
      "    return 0;",
      "}"
    ],
    "description": ""
  }
  }